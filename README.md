# PR Reviewer Assignment Service (Test Task, Fall 2025)

Практическое задание в рамках отбора на стажировку Авито

### Описание задачи

Необходимо реализовать сервис, который назначает ревьюеров на PR из команды автора, позволяет выполнять переназначение ревьюверов и получать список PR’ов, назначенных конкретному пользователю, а также управлять командами и активностью пользователей. После merge PR изменение состава ревьюверов запрещено.

### Общие вводные

**Пользователь (User)** — участник команды с уникальным идентификатором, именем и флагом активности `isActive`.  
**Команда (Team)** — группа пользователей с уникальным именем.  
**Pull Request (PR)** — сущность с идентификатором, названием, автором, статусом `OPEN|MERGED`и списком назначенных ревьюверов (до 2).

1. При создании PR автоматически назначаются **до двух** активных ревьюверов из **команды автора**, исключая самого автора.
2. Переназначение заменяет одного ревьювера на случайного **активного** участника **из команды заменяемого** ревьювера.
3. После `MERGED` менять список ревьюверов **нельзя**.
4. Если доступных кандидатов меньше двух, назначается доступное количество (0/1).

### Условия

* Использовать [этот](docs/openapi.yaml) API.
* Объём данных умеренный (до 20 команд и до 200 пользователей), RPS — 5, SLI времени ответа — 300 мс, SLI успешности — 99.9%.
* Пользователь с `isActive = false` не должен назначаться на ревью.
* Операция merge должна быть **идемпотентной** — повторный вызов не приводит к ошибке и возвращает актуальное состояние PR.
* Сервис и его зависимости должны подниматься командой **docker-compose up**. Если решение предусматривает миграции, они также должны применяться при выполнении этой команды. Сервис должен быть доступен на порту 8080.

### Дополнительные задания

* Добавить простой эндпоинт статистики (например, количество назначений по пользователям и/или по PR).
* Провести нагрузочное тестирование полученного решения и приложить краткие результаты тестирования к решению.
* Добавить метод массовой деактивации пользователей команды и безопасную переназначаемость открытых PR (стремиться уложиться в 100 мс для средних объёмов данных).
* Реализовать интеграционное или E2E-тестирование.
* Описать конфигурацию линтера.

## Реализация

Приложение реализовано полностью согласно основным требованиям на языке Golang, используется база данных PostgreSQL. Также добавлены:
* нагрузочное и интеграционное тестирование;
* конфигурация golangci-lint;
* эндпойнты статистики (```/team/stats```) и деактивации пользователей в команде (```/team/deactivate```);
* CI-пайплайны в GitHub Actions для линтера и интеграционных тестов;
* поддержка Swagger UI (работает файловый сервер с компонентами пользовательского интерфейса).

Конфигурация сервиса задается через [yaml-файл](config/config.yaml).

## API

Для загрузки Swagger UI в браузере необходимо перейти по пути ```/swagger/index.html```.

По умолчанию для клиентских запросов прослушивается порт 8080. Изменить его можно в [файле конфигурации](config/config.yaml) (поле ```http.address```).

## Запуск приложения

Сборка Docker-образа приложения:

```bash
make build_services
```

Развертывание приложения совместно с базой данных:

```bash
make launch_services
```

Развертывание приложения, базы данных и запуск интеграционных тестов:
```bash
make launch_services_with_tests
```

Остановка всех сервисов и удаление контейнеров:

```bash
make stop_services
```

## Нагрузочное тестирование

Для проверки работоспособности сервиса под заданной нагрузкой была написана вспомогательная [программа](load/vegeta.go) при помощи библиотеки Vegeta. Сервис тестировался с 5 RPS в течение 120 cекунд.  
Как видно из отчета ниже, реализованный сервис успешно справляется с нагрузкой и соблюдает необходимые SLI.

### Отчет Vegeta

```
Requests      [total, rate, throughput]  600, 5.01, 2.50
Duration      [total, attack, wait]      1m59.802293785s, 1m59.800412712s, 1.881073ms
Latencies     [mean, 50, 95, 99, max]    3.009492ms, 2.023012ms, 5.147658ms, 19.288809ms, 61.236619ms
Bytes In      [total, mean]              309700, 516.17
Bytes Out     [total, mean]              1190489, 1984.15
Status Codes  [code:count]               200:181  201:119  400:190  404:24  409:86  
Error Set:
404 Not Found
400 Bad Request
409 Conflict
```

## Вопросы и уточнения по условиям/реализации


### Вопрос 1

В описании запроса ```/team/add``` упоминается "создание/обновление пользователей". Как это должно быть реализовано?

**Решение**

Из описания API следует, что невозможно создать команду с уже существующим именем, при этом пользователь может принадлежать одновременно только одной команде.  
Исходя из этого, наиболее логичная схема исполнения запроса следующая:
* создается новая команда, если уже существовала — возвращаем код 400
* создаются новые пользователи, если пользователи с некоторыми ID уже существовали — обновляем информацию о них вместо вставки (upsert), с изменением команды

### Вопрос 2

Что именно должен возвращать эндпойнт статистики?

**Решение**

Разумно предоставить возможность получить статистику по команде:
* количество ревью открытых PR у каждого участника команды;
* количество ревьюеров PR, созданных участниками каманды (с сортировкой по open/merged).

Пример запроса:

```bash
curl -X 'GET' \
  'http://localhost:8080/team/stats?team_name=payments' \
  -H 'accept: application/json'
```

Пример возможного тела ответа:

```json
{
  "team_name": "payments",
  "user_stats": [
    {
      "user_id": "u1",
      "open_reviews_count": 0
    },
    {
      "user_id": "u2",
      "open_reviews_count": 1
    }
  ],
  "pr_stats": [
    {
      "pull_request_id": "pr-1001",
      "status": "OPEN",
      "reviewers_count": 1
    },
    {
      "pull_request_id": "pr-1002",
      "status": "MERGED",
      "reviewers_count": 1
    },
  ]
}
```

### Вопрос 3

Не совсем понятна бизнес-логика деактивации пользователя. Нужно ли автоматически снимать пользователя со всех ревью при выставлении ```isActive = false```?

***Решение***

Условие "пользователь с ```isActive = false``` не должен назначаться на ревью" может быть трактовано двояко. Однако здесь играет роль следующий момент: если пользователь автоматически снимается с ревью, то мы не можем назначить нового пользователя, поскольку метод ```/pullRequest/create``` не предусматривает upsert PR, а эндпойнт назначения пользователя на ревью (вроде ```/pullRequest/assign```) не предусмотрен базовой спецификацией API. Если бы мы автоматически пытались назначить нового пользователя взамен старого, то при отсутствии других активных участников команды мы все равно не смогли это сделать.

В конечном итоге было решено не снимать пользователей с PR операциями ```/users/setIsActive``` и ```/team/deactivate```, поскольку для переназначения неактивных пользователей есть метод ```/pullRequest/reassign```.

### Вопрос 4

Какие индексы следует создать для таблиц базы данных?

**Решение**

После анализа всех SQL-запросов было решено создать следующие индексы (помимо первичных ключей):
* **users (team_name, is_active)** — для эффективной фильтрации
* **reviewers (pr_id)** — для получения списка ревьюеров PR
* **reviewers (user_id, pr_id)** — обеспечивает максимальную эффективность для ряда запросов, т. к. является покрывающим
* **pull_requests (status, id)** — для эффективного получения статистики

### Вопрос 5

Имеет ли смысл использовать кэширование запросов?

**Решение**

С учетом того, что сервис используется довольно локальной группой пользователей и имеет низкий ожидаемый RPS, кэширование в данном случае избыточно.

### Вопрос 6

Модель PR имеет поле ```createdAt```, но его по какой-то причине нет в примере ответа.

**Решение**

В реализации поле ```createdAt``` возвращается всегда.  
Поле ```mergedAt``` возвращается только в случае, если PR уже merged.
